<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data-Driven Betting Pipeline</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298, #3b82f6);
            min-height: 100vh;
            color: #ffffff;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .control-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .control-group h3 {
            margin-bottom: 15px;
            color: #ffd700;
            font-size: 1.1rem;
        }
        .input-group {
            margin-bottom: 15px;
        }
        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
            color: #e2e8f0;
        }
        .input-group input, .input-group select {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            font-size: 0.9rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #ffd700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }
        .btn {
            background: linear-gradient(45deg, #00c851, #28a745);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }
        .results {
            margin-top: 30px;
        }
        .match-analysis {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .match-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        .match-teams {
            font-size: 1.2rem;
            font-weight: bold;
        }
        .match-time {
            background: rgba(255, 215, 0, 0.2);
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.9rem;
        }
        .analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .metric {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        .metric-label {
            font-size: 0.8rem;
            color: #cbd5e0;
            margin-bottom: 5px;
        }
        .metric-value {
            font-size: 1.1rem;
            font-weight: bold;
            color: #ffffff;
        }
        .recommendation {
            background: linear-gradient(45deg, #667eea, #764ba2);
            padding: 20px;
            border-radius: 12px;
            margin-top: 15px;
        }
        .rec-high-ev { background: linear-gradient(45deg, #00c851, #28a745); }
        .rec-medium-ev { background: linear-gradient(45deg, #ff8f00, #ff6f00); }
        .rec-no-bet { background: linear-gradient(45deg, #d32f2f, #b71c1c); }
        .recommendation h4 { margin-bottom: 10px; font-size: 1.1rem; }
        .bet-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        .bet-detail {
            text-align: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
        }
        .portfolio-summary {
            background: rgba(255, 255, 255, 0.1);
            padding: 25px;
            border-radius: 15px;
            margin-top: 30px;
            border: 2px solid rgba(255, 215, 0, 0.3);
        }
        .portfolio-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-top: 15px;
        }
        .portfolio-item {
            text-align: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }
        .portfolio-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 5px;
        }
        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.2rem;
            color: #ffd700;
        }
        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #ffd700;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .hidden { display: none; }
        option { background: #2a5298; color: white; }
        .disclaimer {
            text-align: center;
            font-size: 0.8rem;
            color: #e2e8f0;
            margin-top: 40px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéØ Data-Driven Betting Pipeline</h1>
            <p>Advanced EV+ Selection System | May 2025 Framework</p>
        </div>
        <div class="controls">
            <div class="control-group">
                <h3>‚öôÔ∏è System Parameters</h3>
                <div class="input-group">
                    <label>Current Bankroll ($)</label>
                    <input type="number" id="bankroll" value="10000" min="100">
                </div>
                <div class="input-group">
                    <label>Singles EV Threshold (%)</label>
                    <input type="number" id="singlesEV" value="10" step="0.1" min="0">
                </div>
                <div class="input-group">
                    <label>System EV Threshold (%)</label>
                    <input type="number" id="systemEV" value="2" step="0.1" min="0">
                </div>
            </div>
            <div class="control-group">
                <h3>üìä Model Settings</h3>
                <div class="input-group">
                    <label>Confidence Threshold</label>
                    <input type="number" id="confidence" value="0.65" step="0.01" min="0" max="1">
                </div>
                <div class="input-group">
                    <label>Kelly Fraction</label>
                    <input type="number" id="kellyFraction" value="0.5" step="0.1" min="0.1" max="1">
                </div>
                <div class="input-group">
                    <label>Max Stake per Bet (%)</label>
                    <input type="number" id="maxStake" value="5" step="0.5" min="0.5" max="10">
                </div>
            </div>
            <div class="control-group">
                <h3>üé≤ Portfolio Allocation</h3>
                <div class="input-group">
                    <label>Singles Pool (%)</label>
                    <input type="number" id="singlesAllocation" value="40" min="0" max="100">
                </div>
                <div class="input-group">
                    <label>Systems Pool (%)</label>
                    <input type="number" id="systemsAllocation" value="60" min="0" max="100">
                </div>
                <div class="input-group">
                    <label>Analysis Mode</label>
                    <select id="analysisMode">
                        <option value="conservative">Conservative</option>
                        <option value="balanced" selected>Balanced</option>
                        <option value="aggressive">Aggressive</option>
                    </select>
                </div>
            </div>
        </div>
        <div style="text-align: center; margin-bottom: 30px;">
            <input type="file" id="matchesFile" accept=".json" style="margin-right:15px;">
            <button class="btn" onclick="runAnalysis()">üöÄ Run Full Analysis</button>
            <button class="btn" onclick="loadTodaysMatches()" style="background: linear-gradient(45deg, #2196f3, #1976d2); margin-left: 15px;">üìÖ Load Matches</button>
            <button class="btn" onclick="fetchMatchesFromWeb()" style="background: linear-gradient(45deg, #ff9800, #f57c00); margin-left: 15px;">üîé Fetch Web Matches</button>
        </div>
        <div id="loading" class="loading hidden">
            <div class="spinner"></div>
            <p>Analyzing matches and calculating optimal selections...</p>
        </div>
        <div id="results" class="results"></div>
        <div id="portfolio" class="portfolio-summary hidden">
            <h3 style="text-align: center; margin-bottom: 20px; color: #ffd700;">üìà Portfolio Summary</h3>
            <div class="portfolio-grid">
                <div class="portfolio-item">
                    <div class="portfolio-value" id="totalStake">$0</div>
                    <div>Total Stake</div>
                </div>
                <div class="portfolio-item">
                    <div class="portfolio-value" id="expectedReturn">$0</div>
                    <div>Expected Return</div>
                </div>
                <div class="portfolio-item">
                    <div class="portfolio-value" id="totalEV">0%</div>
                    <div>Portfolio EV</div>
                </div>
                <div class="portfolio-item">
                    <div class="portfolio-value" id="singlesCount">0</div>
                    <div>Singles Bets</div>
                </div>
                <div class="portfolio-item">
                    <div class="portfolio-value" id="systemsCount">0</div>
                    <div>System Legs</div>
                </div>
                <div class="portfolio-item">
                    <div class="portfolio-value" id="riskLevel">Low</div>
                    <div>Risk Level</div>
                </div>
            </div>
        </div>
    </div>
    <script>
        class BettingFramework {
            constructor() {
                this.matches = [];
                this.parameters = this.getParameters();
                this.applyAnalysisMode();
                this.initializeTeamRatings();
                this.performanceHistory = [];
            }
            getParameters() {
                return {
                    bankroll: parseFloat(document.getElementById('bankroll').value),
                    singlesEV: parseFloat(document.getElementById('singlesEV').value) / 100,
                    systemEV: parseFloat(document.getElementById('systemEV').value) / 100,
                    confidence: parseFloat(document.getElementById('confidence').value),
                    kellyFraction: parseFloat(document.getElementById('kellyFraction').value),
                    maxStake: parseFloat(document.getElementById('maxStake').value) / 100,
                    singlesAllocation: parseFloat(document.getElementById('singlesAllocation').value) / 100,
                    systemsAllocation: parseFloat(document.getElementById('systemsAllocation').value) / 100,
                    analysisMode: document.getElementById('analysisMode').value
                };
            }
            applyAnalysisMode() {
                if (this.parameters.analysisMode === 'conservative') {
                    this.parameters.singlesEV += 0.05;
                    this.parameters.systemEV += 0.02;
                    this.parameters.confidence += 0.05;
                } else if (this.parameters.analysisMode === 'aggressive') {
                    this.parameters.singlesEV = Math.max(0, this.parameters.singlesEV - 0.05);
                    this.parameters.systemEV = Math.max(0, this.parameters.systemEV - 0.02);
                    this.parameters.confidence = Math.max(0, this.parameters.confidence - 0.05);
                }
            }
            initializeTeamRatings() {
                this.teamData = {
                    'Botswana': { elo: 1420, form: 0.6, homeAdvantage: 0.15, injuries: 0.05, attackRating: 1.2, defenseRating: 1.3 },
                    'Zambia': { elo: 1480, form: 0.75, homeAdvantage: 0, injuries: 0.02, attackRating: 1.4, defenseRating: 1.1 },
                    'Eswatini': { elo: 1380, form: 0.5, homeAdvantage: 0.15, injuries: 0.08, attackRating: 1.0, defenseRating: 1.4 },
                    'Tanzania': { elo: 1520, form: 0.8, homeAdvantage: 0, injuries: 0.03, attackRating: 1.5, defenseRating: 1.0 },
                    'Orbit College FC': { elo: 1450, form: 0.65, homeAdvantage: 0.12, injuries: 0.04, attackRating: 1.2, defenseRating: 1.2 },
                    'Casric Stars FC': { elo: 1440, form: 0.6, homeAdvantage: 0, injuries: 0.06, attackRating: 1.1, defenseRating: 1.3 },
                    'FC Olimpik': { elo: 1480, form: 0.7, homeAdvantage: 0.15, injuries: 0.03, attackRating: 1.3, defenseRating: 1.0 },
                    'Pfk Aral': { elo: 1520, form: 0.75, homeAdvantage: 0, injuries: 0.02, attackRating: 1.6, defenseRating: 0.9 },
                    'Znk Hajduk Split': { elo: 1380, form: 0.4, homeAdvantage: 0.12, injuries: 0.08, attackRating: 0.8, defenseRating: 1.6 },
                    'Znk Agram': { elo: 1620, form: 0.85, homeAdvantage: 0, injuries: 0.02, attackRating: 1.7, defenseRating: 0.8 },
                    'Gimnasia de Mendoza Reserve': { elo: 1680, form: 0.9, homeAdvantage: 0.15, injuries: 0.01, attackRating: 1.8, defenseRating: 0.7 },
                    'Defensores Unidos Reserve': { elo: 1320, form: 0.3, homeAdvantage: 0, injuries: 0.12, attackRating: 0.6, defenseRating: 1.8 },
                    'Sportive de Douala': { elo: 1350, form: 0.45, homeAdvantage: 0.15, injuries: 0.07, attackRating: 0.9, defenseRating: 1.5 },
                    'Fauve Azur de Yaounde': { elo: 1580, form: 0.8, homeAdvantage: 0, injuries: 0.03, attackRating: 1.6, defenseRating: 0.9 },
                    'Haka': { elo: 1450, form: 0.65, homeAdvantage: 0.12, injuries: 0.04, attackRating: 1.2, defenseRating: 1.2 },
                    'Gnistan': { elo: 1420, form: 0.6, homeAdvantage: 0, injuries: 0.06, attackRating: 1.1, defenseRating: 1.3 },
                    'OLS Oulu': { elo: 1380, form: 0.5, homeAdvantage: 0.12, injuries: 0.08, attackRating: 0.9, defenseRating: 1.4 },
                    'EIF': { elo: 1580, form: 0.8, homeAdvantage: 0, injuries: 0.03, attackRating: 1.6, defenseRating: 0.9 },
                    'Podhale Nowy Targ': { elo: 1520, form: 0.7, homeAdvantage: 0.15, injuries: 0.04, attackRating: 1.4, defenseRating: 1.1 },
                'Legia Warszawa II': { elo: 1480, form: 0.65, homeAdvantage: 0, injuries: 0.05, attackRating: 1.3, defenseRating: 1.2 }
                };
            }

            updateTeamRatings(match, result){
                const K = 32;
                const expected = this.calculateTrueProbability(match.home, match.away).home;
                const actualHome = result === 'home' ? 1 : result === 'draw' ? 0.5 : 0;
                if(this.teamData[match.home]){
                    this.teamData[match.home].elo += K * (actualHome - expected);
                }
                if(this.teamData[match.away]){
                    this.teamData[match.away].elo += K * ((1 - actualHome) - (1 - expected));
                }
            }

            trackPerformance(selections, results){
                const performance = {
                    timestamp: Date.now(),
                    selections: selections.length,
                    wins: results.filter(r => r.won).length,
                    totalStake: selections.reduce((s,b) => s + b.stake, 0),
                    totalReturn: results.reduce((s,r) => s + (r.won ? r.payout : 0), 0)
                };
                this.performanceHistory.push(performance);
            }
            calculateExpectedGoals(homeTeam, awayTeam) {
                const homeData = this.teamData[homeTeam] || { attackRating: 1.2, defenseRating: 1.2 };
                const awayData = this.teamData[awayTeam] || { attackRating: 1.2, defenseRating: 1.2 };
                const homeGoals = 1.3 * homeData.attackRating * awayData.defenseRating;
                const awayGoals = 1.1 * awayData.attackRating * homeData.defenseRating;
                const totalGoals = homeGoals + awayGoals;
                return { homeGoals, awayGoals, totalGoals };
            }
            calculateOverUnderProbability(totalExpectedGoals, line) {
                const lambda = totalExpectedGoals;
                const probUnder = Math.exp(-lambda) * Math.pow(lambda, line) / this.factorial(line);
                const probOver = 1 - probUnder;
                if (line % 1 === 0.5) {
                    const floorLine = Math.floor(line);
                    const ceilLine = Math.ceil(line);
                    const probFloor = this.poissonCDF(floorLine, lambda);
                    return { over: 1 - probFloor, under: probFloor };
                }
                return { over: probOver, under: probUnder };
            }
            poissonCDF(k, lambda) {
                let sum = 0;
                for (let i = 0; i <= k; i++) {
                    sum += Math.exp(-lambda) * Math.pow(lambda, i) / this.factorial(i);
                }
                return sum;
            }
            factorial(n) { return n <= 1 ? 1 : n * this.factorial(n - 1); }
            calculateTrueProbability(homeTeam, awayTeam) {
                const homeData = this.teamData[homeTeam] || { elo: 1500, form: 0.5, homeAdvantage: 0.1, injuries: 0.05 };
                const awayData = this.teamData[awayTeam] || { elo: 1500, form: 0.5, homeAdvantage: 0, injuries: 0.05 };
                const eloDiff = homeData.elo - awayData.elo;
                const formDiff = homeData.form - awayData.form;
                const homeAdv = homeData.homeAdvantage;
                const injuryPenalty = homeData.injuries - awayData.injuries;
                const alpha = 0.003;
                const beta = 0.4;
                const gamma = 0.3;
                const logit = alpha * eloDiff + beta * homeAdv + gamma * (formDiff - injuryPenalty);
                const probHome = 1 / (1 + Math.exp(-logit));
                const probDraw = 0.25 + 0.1 * Math.random();
                const probAway = 1 - probHome - probDraw;
                return {
                    home: Math.max(0.05, Math.min(0.90, probHome)),
                    draw: Math.max(0.15, Math.min(0.40, probDraw)),
                    away: Math.max(0.05, Math.min(0.90, probAway))
                };
            }
            calculateEV(p, odds) { return odds <= 1 ? -1 : p * (odds - 1) - (1 - p); }
            calculateKellyStake(p, odds, bankroll) {
                if (!odds || odds <= 1) return 0;
                const b = odds - 1;
                const q = 1 - p;
                const kelly = (p * b - q) / b;
                const adj = kelly * this.parameters.kellyFraction;
                const stake = Math.max(0, adj * bankroll);
                return Math.min(stake, bankroll * this.parameters.maxStake);
            }
            getConfidenceScore(homeTeam, awayTeam, market) {
                const homeData = this.teamData[homeTeam] || { elo: 1500, form: 0.5 };
                const awayData = this.teamData[awayTeam] || { elo: 1500, form: 0.5 };
                const eloDiff = Math.abs(homeData.elo - awayData.elo);
                const formStability = Math.min(homeData.form, awayData.form);
                let base = 0.5 + (eloDiff / 1000) + (formStability * 0.3);
                if (market === '1X2') base *= 0.9;
                if (market === 'doubleChance') base *= 1.1;
                if (market === 'Over' || market === 'Under') base *= 0.95;
                return Math.min(0.95, Math.max(0.3, base));
            }
            createErrorAnalysis(match, error){
                return {
                    match: `${match.home || '?'} vs ${match.away || '?'}`,
                    time: match.time || '',
                    error: error.message,
                    markets: []
                };
            }

            analyzeMatch(match) {
                try {
                    if(!match || !match.home || !match.away || !match.odds){
                        throw new Error('Invalid match data');
                    }
                    const { home, away, odds, time } = match;
                    const trueProb = this.calculateTrueProbability(home, away);
                    const expected = this.calculateExpectedGoals(home, away);
                    const ou = this.calculateOverUnderProbability(expected.totalGoals, odds.goals);
                const markets = [
                    { name: 'Home Win (1)', probability: trueProb.home, odds: odds.home, type: '1' },
                    { name: 'Draw (X)', probability: trueProb.draw, odds: odds.draw, type: 'X' },
                    { name: 'Away Win (2)', probability: trueProb.away, odds: odds.away, type: '2' },
                    { name: 'Home/Draw (1X)', probability: trueProb.home + trueProb.draw, odds: odds.homeX, type: '1X' },
                    { name: 'Home/Away (12)', probability: trueProb.home + trueProb.away, odds: odds.homeAway, type: '12' },
                    { name: 'Draw/Away (X2)', probability: trueProb.draw + trueProb.away, odds: odds.drawAway, type: 'X2' },
                    { name: `Over ${odds.goals}`, probability: ou.over, odds: odds.over, type: 'Over' },
                    { name: `Under ${odds.goals}`, probability: ou.under, odds: odds.under, type: 'Under' }
                ];
                    const analysis = { match: `${home} vs ${away}`, time, expectedGoals: expected, markets: [] };
                for (const m of markets) {
                    if (!m.odds || m.odds <= 1) continue;
                    const ev = this.calculateEV(m.probability, m.odds);
                    const conf = this.getConfidenceScore(home, away, m.type);
                    const adjustedEV = ev * conf;
                    const stake = this.calculateKellyStake(m.probability, m.odds, this.parameters.bankroll);
                    analysis.markets.push({
                        name: m.name,
                        type: m.type,
                        probability: m.probability,
                        impliedProbability: 1 / m.odds,
                        odds: m.odds,
                        ev,
                        adjustedEV,
                        confidence: conf,
                        stake,
                        expectedReturn: stake * m.odds * m.probability
                    });
                }
                    return analysis;
                } catch(error){
                    console.error('Match analysis failed:', error.message);
                    return this.createErrorAnalysis(match, error);
                }
            }
            filterSelections(analyses) {
                const singles = [];
                const systemLegs = [];
                for (const a of analyses) {
                    for (const m of a.markets) {
                        const systemOk = m.adjustedEV >= this.parameters.systemEV && m.confidence >= this.parameters.confidence;
                        const singleOk = m.adjustedEV >= this.parameters.singlesEV && m.confidence >= this.parameters.confidence + 0.1;
                        if (singleOk) singles.push({ ...m, match: a.match, time: a.time, category: 'single' });
                        else if (systemOk) systemLegs.push({ ...m, match: a.match, time: a.time, category: 'system' });
                    }
                }
                singles.sort((a,b)=>b.adjustedEV-a.adjustedEV);
                systemLegs.sort((a,b)=>b.adjustedEV-a.adjustedEV);
                return { singles: singles.slice(0,7), systemLegs: systemLegs.slice(0,10) };
            }
            applyAllocation(selections){
                const singlesBudget=this.parameters.bankroll*this.parameters.singlesAllocation;
                const systemsBudget=this.parameters.bankroll*this.parameters.systemsAllocation;
                const singlesTotal=selections.singles.reduce((s,b)=>s+b.stake,0);
                if(singlesTotal>singlesBudget){
                    const f=singlesBudget/singlesTotal;
                    selections.singles.forEach(b=>{
                        b.stake*=f;
                        b.expectedReturn=b.stake*b.odds*b.probability;
                    });
                }
                const systemsTotal=selections.systemLegs.reduce((s,b)=>s+b.stake,0);
                if(systemsTotal>systemsBudget){
                    const f=systemsBudget/systemsTotal;
                    selections.systemLegs.forEach(b=>{
                        b.stake*=f;
                        b.expectedReturn=b.stake*b.odds*b.probability;
                    });
                }
                return selections;
            }
            calculatePortfolioMetrics(selections) {
                const singlesStake = selections.singles.reduce((sum, b)=>sum+b.stake,0);
                const systemsStake = selections.systemLegs.reduce((sum,b)=>sum+b.stake,0);
                const totalStake = singlesStake + systemsStake;
                const singlesReturn = selections.singles.reduce((sum,b)=>sum+b.expectedReturn,0);
                const systemsReturn = selections.systemLegs.reduce((sum,b)=>sum+(b.stake*b.odds*b.probability),0);
                const expectedReturn = singlesReturn + systemsReturn;
                const portfolioEV = totalStake>0 ? (expectedReturn-totalStake)/totalStake : 0;
                let riskLevel = 'Low';
                if (portfolioEV>0.15) riskLevel='High';
                else if (portfolioEV>0.08) riskLevel='Medium';
                return { totalStake, expectedReturn, portfolioEV, singlesCount: selections.singles.length, systemsCount: selections.systemLegs.length, riskLevel };
            }
            analyzeMatches(matches){
                const analyses = matches.map(m=>this.analyzeMatch(m));
                let selections = this.filterSelections(analyses);
                selections = this.applyAllocation(selections);
                const portfolio = this.calculatePortfolioMetrics(selections);
                return { analyses, selections, portfolio };
            }
        }
        function mockMatches(){
            return [
                { home:'Botswana', away:'Zambia', time:'12:00', odds:{ home:2.8, draw:3.1, away:2.4, homeX:1.6, homeAway:1.4, drawAway:1.6, goals:2.5, over:1.9, under:1.9 } },
                { home:'Haka', away:'Gnistan', time:'16:00', odds:{ home:1.8, draw:3.3, away:4.0, homeX:1.3, homeAway:1.2, drawAway:2.0, goals:2.5, over:1.8, under:2.0 } }
            ];
        }
        function displayResults(result){
            const res = document.getElementById('results');
            res.innerHTML='';
            for(const a of result.analyses){
                const div=document.createElement('div');
                div.className='match-analysis';
                const header=document.createElement('div');
                header.className='match-header';
                header.innerHTML=`<div class="match-teams">${a.match}</div><div class="match-time">${a.time}</div>`;
                div.appendChild(header);
                const grid=document.createElement('div');
                grid.className='analysis-grid';
                const metrics=[
                    {label:'Home Win', value:(a.markets[0].probability*100).toFixed(1)+'%'},
                    {label:'Draw', value:(a.markets[1].probability*100).toFixed(1)+'%'},
                    {label:'Away Win', value:(a.markets[2].probability*100).toFixed(1)+'%'},
                    {label:'Total Goals', value:a.expectedGoals.totalGoals.toFixed(2)}
                ];
                for(const m of metrics){
                    const md=document.createElement('div');
                    md.className='metric';
                    md.innerHTML=`<div class="metric-label">${m.label}</div><div class="metric-value">${m.value}</div>`;
                    grid.appendChild(md);
                }
                div.appendChild(grid);
                res.appendChild(div);
            }
            const port=document.getElementById('portfolio');
            port.classList.remove('hidden');
            document.getElementById('totalStake').innerText='$'+result.portfolio.totalStake.toFixed(2);
            document.getElementById('expectedReturn').innerText='$'+result.portfolio.expectedReturn.toFixed(2);
            document.getElementById('totalEV').innerText=(result.portfolio.portfolioEV*100).toFixed(2)+'%';
            document.getElementById('singlesCount').innerText=result.portfolio.singlesCount;
            document.getElementById('systemsCount').innerText=result.portfolio.systemsCount;
            document.getElementById('riskLevel').innerText=result.portfolio.riskLevel;
        }
        function runAnalysis(){
            document.getElementById('loading').classList.remove('hidden');
            setTimeout(()=>{
                const framework=new BettingFramework();
                const matches=mockMatches();
                const res=framework.analyzeMatches(matches);
                document.getElementById('loading').classList.add('hidden');
                displayResults(res);
            },500);
        }
        function loadTodaysMatches(){
            const fileInput = document.getElementById('matchesFile');
            const file = fileInput.files[0];
            if(!file){
                alert('Please select a matches JSON file first.');
                return;
            }
            document.getElementById('loading').classList.remove('hidden');
            const reader = new FileReader();
            reader.onload = e => {
                try{
                    const data = JSON.parse(e.target.result);
                    const framework = new BettingFramework();
                    const res = framework.analyzeMatches(data);
                    displayResults(res);
                }catch(err){
                    alert('Invalid matches file: '+err.message);
                }finally{
                    document.getElementById('loading').classList.add('hidden');
                }
            };
            reader.readAsText(file);
        }
        async function fetchMatchesFromWeb(){
            document.getElementById('loading').classList.remove('hidden');
            try {
                const res = await fetch('http://127.0.0.1:3001/scrape');
                const data = await res.json();
                const scraped = Array.isArray(data) ? data : data.matches;
                if(scraped && scraped.length){
                    const matches = scraped.map(m => {
                        const [home, away] = m.match.split(' vs ');
                        return {
                            home: home || '',
                            away: away || '',
                            time: m.time || '',
                            odds: {
                                home: m.markets['1'],
                                draw: m.markets['X'],
                                away: m.markets['2'],
                                homeX: m.markets['1X'],
                                homeAway: m.markets['12'],
                                drawAway: m.markets['X2'],
                                goals: 2.5,
                                over: m.markets['Over 2.5'],
                                under: m.markets['Under 2.5']
                            }
                        };
                    });
                    const framework = new BettingFramework();
                    const result = framework.analyzeMatches(matches);
                    displayResults(result);
                } else {
                    alert('No matches received.');
                }
            } catch(e) {
                console.error('Backend connection failed:', e);
                document.getElementById('results').innerHTML = `
                    <div style="background: linear-gradient(45deg, #ff6b6b, #ee5a24); color: white; padding: 20px; border-radius: 12px; text-align: center;">
                        <h3>üîå Backend Server Not Running</h3>
                        <p><strong>Error:</strong> ${e.message}</p>
                        <div style="margin-top: 15px; font-size: 0.9rem;">
                            <p><strong>Quick Fix:</strong></p>
                            <ol style="text-align: left; display: inline-block;">
                                <li>Open a new terminal in your project folder</li>
                                <li>Run: <code>npm install</code></li>
                                <li>Run: <code>npm start</code></li>
                                <li>Wait for "Server running on port 3001"</li>
                                <li>Try fetching again</li>
                            </ol>
                        </div>
                        <button onclick="fetchMatchesFromWeb()" style="margin-top: 15px; padding: 10px 20px; background: white; color: #333; border: none; border-radius: 6px; cursor: pointer;">
                            üîÑ Retry Connection
                        </button>
                    </div>
                `;
            } finally {
                document.getElementById('loading').classList.add('hidden');
            }
        }
    </script>
    <footer class="disclaimer">
        <p>All data is for informational purposes only. Please gamble responsibly.</p>
    </footer>
</body>
</html>
